# -*- coding: utf-8 -*-
"""Value_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z3Kvg0mDejXqRaXYNvH1jGAwDjlbQoNV
"""

# -*- coding: utf-8 -*-
"""techne3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11TSMLLMbNR6QNLYYDqGHjiSJIQtYG5ot
"""

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import keras
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from keras.optimizers import Adam,RMSprop,SGD,Adamax,Adagrad,Adadelta,Nadam
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from keras.models import Sequential
from keras.layers import Dense

# Load the dataset
df = pd.read_csv('health_vitals_data.csv')

# Separate features and target variable
X = df.drop(columns=['Fitness Score'])
y = df['Fitness Score']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=28)

# Preprocess categorical columns (like 'Gender') using one-hot encoding
categorical_cols = ['Gender']
ct = ColumnTransformer(transformers=[('encoder', OneHotEncoder(), categorical_cols)], remainder='passthrough')
X_train = ct.fit_transform(X_train)
X_test = ct.transform(X_test)

# Normalize the data
scaler = MinMaxScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Build the Neural Network model
model = Sequential()
model.add(Dense(64, input_dim=X_train.shape[1], activation='relu'))
model.add(Dense(32, activation='relu'))
model.add(Dense(1, activation='linear'))

# Compile the model
optimizer = keras.optimizers.Nadam(learning_rate=0.001)
model.compile(optimizer=optimizer, loss='mse')

# Train the model
history = model.fit(X_train, y_train, epochs=180, batch_size=32, validation_split=0.2)

# Make predictions
y_pred = model.predict(X_test).flatten()

mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mse)

print(f'Mean Squared Error: {mse}')
print(f'R-squared (R2) Score: {r2}')
print(f'Mean Absolute Error (MAE): {mae}')
print(f'Root Mean Squared Error (RMSE): {rmse}')


# ... (previous code)

# ... (previous code)

# Health Vitals Normalization and Ideal Fitness Score Calculation
def normalize_heart_rate(heart_rate):
    # Normalize heart rate to a scale between 0 and 1
    min_heart_rate = 50  # Minimum healthy heart rate
    max_heart_rate = 100  # Maximum healthy heart rate
    normalized_heart_rate = (heart_rate - min_heart_rate) / (max_heart_rate - min_heart_rate)
    return normalized_heart_rate

# ... (other normalization functions as before)

def normalize_stress_level(stress_level):
    # Assuming stress level is given as a string ('Low', 'Medium', 'High')
    # You can define a mapping function to convert it to a numeric value for normalization
    stress_mapping = {'Low': 0.0, 'Medium': 0.5, 'High': 1.0}
    return stress_mapping.get(stress_level, 0.0)

# ... (other functions as before)

def preprocess_input_data(new_health_vitals):
    # Preprocess the new health vitals data using the same ColumnTransformer and MinMaxScaler used during training
    new_health_vitals_encoded = ct.transform(new_health_vitals)
    new_health_vitals_normalized = scaler.transform(new_health_vitals_encoded)
    return new_health_vitals_normalized

def predict_fitness_score(model, ct, scaler, new_health_vitals):
    # Preprocess the input data
    new_health_vitals_copy = new_health_vitals.copy()
    new_health_vitals_copy['Stress Level'] = new_health_vitals_copy['Stress Level'].apply(normalize_stress_level)
    new_health_vitals_normalized = preprocess_input_data(new_health_vitals_copy)

    # Make predictions using the loaded model
    predicted_fitness_scores = model.predict(new_health_vitals_normalized).flatten()
    return predicted_fitness_scores


# ... (previous code)

# Call the function to test the trained model with new health vitals data
new_health_vitals_data = {
    'Gender': ['Male'],
    'Age': [35],
    'Daily Steps': [7000],
    'Heart Rate': [72],
    'Sleep Duration': [7],
    'Systolic': [122],
    'Diastolic': [78],
    'Stress Level': ['Medium']
}

# Convert the new health vitals data dictionary to a DataFrame
new_health_vitals_df = pd.DataFrame(new_health_vitals_data)

# Call the predict_fitness_score function with the loaded model and new health vitals data
predictions = predict_fitness_score(model, ct, scaler, new_health_vitals_df)

print("Predicted Fitness Score:", predictions[0])