# -*- coding: utf-8 -*-
"""techne_GBR_ANN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13TnAipb2iSIyodf0gHSXr-6ZFqLUJ1dJ
"""

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import keras
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from keras.optimizers import Adam,RMSprop,SGD,Adamax,Adagrad,Adadelta,Nadam
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
from keras.models import Sequential
from keras.layers import Dense
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import pickle

df0 = pd.read_csv('original_data.csv')

df0

df0.info()

df0.head(5)

df0.drop(['Person ID', 'Occupation','Quality of Sleep','Physical Activity Level','BMI Category','Sleep Disorder'], axis=1, inplace=True)

df0.head()

# Assuming 'gender' is a categorical variable that needs encoding
df0['Gender'] = df0['Gender'].map({'Male': 0, 'Female': 1})

df0

# Preprocess the 'Blood Pressure' column
df0[['Systolic', 'Diastolic']] = df0['Blood Pressure'].str.split('/', expand=True)
df0[['Systolic', 'Diastolic']] = df0[['Systolic', 'Diastolic']].astype(float)

# Drop the original 'Blood Pressure' column
df0.drop(columns=['Blood Pressure'], inplace=True)

df0

from sklearn.preprocessing import MinMaxScaler

# Assuming X contains the features (Age, Sleep Duration, Stress Level, Heart Rate, Daily Steps, Systolic, Diastolic)
numerical_features = ['Age', 'Sleep Duration', 'Stress Level', 'Heart Rate', 'Daily Steps', 'Systolic', 'Diastolic']

# Initialize MinMaxScaler
scaler = MinMaxScaler()

# Normalize the numerical features using MinMaxScaler
df0[numerical_features] = scaler.fit_transform(df0[numerical_features])

df0

weights = {
    'Gender': 0.05,
    'Age': 0.1,
    'Sleep Duration': 0.2,
    'Stress Level': 0.15,
    'Heart Rate': 0.15,
    'Daily Steps': 0.1,
    'Systolic': 0.15,
    'Diastolic': 0.1
}

col= ['Gender','Age', 'Sleep Duration', 'Stress Level', 'Heart Rate', 'Daily Steps', 'Systolic', 'Diastolic']

# Calculate the fitness score using the defined weights
df0['Fitness Score'] = df0[col].dot(pd.Series(weights))

df0

# Save the updated dataset with the fitness score
df0.to_csv('hv.csv', index=False)

"""#Gradient Boosting Regressor"""

df = pd.read_csv('hv_data.csv')

# Define the features (X) and the target variable (y)
X = df.drop(columns=['Fitness Score'])
y = df['Fitness Score']

# Split the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=28)

# Initialize the Gradient Boosting Regressor
gbr_regressor = GradientBoostingRegressor(n_estimators=1000, random_state=48)

# Train the model on the training data
gbr_regressor.fit(X_train, y_train)

# Make predictions on the test set
y_pred = gbr_regressor.predict(X_test)

# Evaluate the model's performance
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
rmse = mean_squared_error(y_test, y_pred, squared=False)

print(f'Mean Squared Error: {mse}')
print(f'R-squared (R2) Score: {r2}')
print(f'Mean Absolute Error (MAE): {mae}')
print(f'Root Mean Squared Error (RMSE): {rmse}')

with open('techne_GBR.pkl', 'wb') as model_file:
    pickle.dump(gbr_regressor,model_file)
# gbr_regressor.save('techne_GBR.h5')

"""#ANN"""

# Load the dataset
df = pd.read_csv('hv_data.csv')

# Separate features and target variable
X = df.drop(columns=['Fitness Score'])
y = df['Fitness Score']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=28)

# # Preprocess categorical columns (like 'Gender') using one-hot encoding
# categorical_cols = ['Gender']
# ct = ColumnTransformer(transformers=[('encoder', OneHotEncoder(), categorical_cols)], remainder='passthrough')
# X_train = ct.fit_transform(X_train)
# X_test = ct.transform(X_test)

# # Normalize the data
# scaler = MinMaxScaler()
# X_train = scaler.fit_transform(X_train)
# X_test = scaler.transform(X_test)

with open('scaler.pkl', 'wb') as f:
    pickle.dump(scaler,f)

# # Build the Neural Network model
# model = keras.Sequential([
#     keras.layers.Dense(64, activation='relu', input_shape=(X_train.shape[1],)),
#     keras.layers.Dense(32, activation='relu'),
#     keras.layers.Dense(1)  # Output layer with a single neuron for regression
# ])
model = Sequential()
model.add(Dense(64, input_dim=X_train.shape[1], activation='relu'))
model.add(Dense(32, activation='relu'))
model.add(Dense(1, activation='linear'))


# Compile the model
optimizer = keras.optimizers.Nadam(learning_rate=0.001)
model.compile(optimizer=optimizer, loss='mse')

# Train the model
history = model.fit(X_train, y_train, epochs=180, batch_size=32, validation_split=0.2)

# Make predictions
y_pred = model.predict(X_test).flatten()

mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mse)

print(f'Mean Squared Error: {mse}')
print(f'R-squared (R2) Score: {r2}')
print(f'Mean Absolute Error (MAE): {mae}')
print(f'Root Mean Squared Error (RMSE): {rmse}')

# with open('techne_ANN.pkl', 'wb') as model_file:
#     pickle.dump(model,model_file)
model.save('techne_ANN.h5')



"""#END DEV COD"""

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.optimizers import Nadam
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error
import pickle

# Load the dataset
df = pd.read_csv('hv.csv')

# Separate features and target variable
X = df.drop(columns=['Fitness Score'])
y = df['Fitness Score']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=28)

# Normalize the features
scaler_X = MinMaxScaler()
X_train_scaled = scaler_X.fit_transform(X_train)
X_test_scaled = scaler_X.transform(X_test)

# Normalize the target
scaler_y = MinMaxScaler()
y_train_scaled = scaler_y.fit_transform(y_train.values.reshape(-1, 1))

# Build the Neural Network model
model = Sequential()
model.add(Dense(64, input_dim=X_train_scaled.shape[1], activation='relu'))
model.add(Dense(32, activation='relu'))
model.add(Dense(1, activation='linear'))

# Compile the model
optimizer = Nadam(learning_rate=0.001)
model.compile(optimizer=optimizer, loss='mse')

# Train the model
history = model.fit(X_train_scaled, y_train_scaled, epochs=180, batch_size=32, validation_split=0.1)

# Make predictions
X_test_scaled = scaler_X.transform(X_test)
y_pred_scaled = model.predict(X_test_scaled).flatten()

# Inverse transform to get values in the original range
y_pred = scaler_y.inverse_transform(y_pred_scaled.reshape(-1, 1)).flatten()

# Calculate errors
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
rmse = np.sqrt(mse)

print(f'Mean Squared Error: {mse}')
print(f'R-squared (R2) Score: {r2}')
print(f'Mean Absolute Error (MAE): {mae}')
print(f'Root Mean Squared Error (RMSE):Â {rmse}')

# Save the trained model to an HDF5 file
model.save('techne_ANN.h5')

# Save the scalers to pickle files
with open('scaler_X.pkl', 'wb') as f:
    pickle.dump(scaler_X, f)

with open('scaler_y.pkl', 'wb') as f:
    pickle.dump(scaler_y, f)













